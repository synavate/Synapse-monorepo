"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oauth4webapi";
exports.ids = ["vendor-chunks/oauth4webapi"];
exports.modules = {

/***/ "(rsc)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   experimentalCustomFetch: () => (/* binding */ experimentalCustomFetch),\n/* harmony export */   experimentalUseMtlsAlias: () => (/* binding */ experimentalUseMtlsAlias),\n/* harmony export */   experimental_customFetch: () => (/* binding */ experimental_customFetch),\n/* harmony export */   experimental_useMtlsAlias: () => (/* binding */ experimental_useMtlsAlias),\n/* harmony export */   experimental_validateDetachedSignatureResponse: () => (/* binding */ experimental_validateDetachedSignatureResponse),\n/* harmony export */   experimental_validateJwtAccessToken: () => (/* binding */ experimental_validateJwtAccessToken),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isOAuth2Error: () => (/* binding */ isOAuth2Error),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   parseWwwAuthenticateChallenges: () => (/* binding */ parseWwwAuthenticateChallenges),\n/* harmony export */   processAuthorizationCodeOAuth2Response: () => (/* binding */ processAuthorizationCodeOAuth2Response),\n/* harmony export */   processAuthorizationCodeOpenIDResponse: () => (/* binding */ processAuthorizationCodeOpenIDResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v2.8.1\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n    } catch  {\n        return false;\n    }\n}\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst experimental_customFetch = Symbol();\nconst experimentalCustomFetch = experimental_customFetch;\nconst experimental_useMtlsAlias = Symbol();\nconst experimentalUseMtlsAlias = experimental_useMtlsAlias;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    } catch (cause) {\n        throw new OPE(\"The input to be decoded is not correctly encoded.\", {\n            cause\n        });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize){\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if (v = this._cache.get(key)) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        } else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message){\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === \"public\";\n}\nconst SUPPORTED_JWS_ALGS = [\n    \"PS256\",\n    \"ES256\",\n    \"RS256\",\n    \"PS384\",\n    \"ES384\",\n    \"RS384\",\n    \"PS512\",\n    \"ES512\",\n    \"RS512\",\n    \"EdDSA\"\n];\nfunction processDpopNonce(response) {\n    try {\n        if (response.headers.has(\"dpop-nonce\")) {\n            const url = new URL(response.url);\n            dpopNonces.set(url.origin, response.headers.get(\"dpop-nonce\"));\n        }\n    } finally{\n        return response;\n    }\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has(\"dpop\")) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch(options?.algorithm){\n        case undefined:\n        case \"oidc\":\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n            break;\n        case \"oauth2\":\n            if (url.pathname === \"/\") {\n                url.pathname = `.well-known/oauth-authorization-server`;\n            } else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === \"string\" && input.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n    }\n}\nfunction getClockSkew(client) {\n    if (client && clockSkew in client) {\n        if (Number.isFinite(client[clockSkew])) {\n            return client[clockSkew];\n        }\n    }\n    return 0;\n}\nfunction getClockTolerance(client) {\n    if (client && clockTolerance in client) {\n        const tolerance = client[clockTolerance];\n        if (Number.isFinite(tolerance) && Math.sign(tolerance) !== -1) {\n            return tolerance;\n        }\n    }\n    return 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [\n            as.issuer,\n            as.token_endpoint\n        ],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n    return jwt({\n        alg: keyToJws(key),\n        kid\n    }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete(\"client_secret\");\n    body.delete(\"client_assertion_type\");\n    body.delete(\"client_assertion\");\n    switch(client.token_endpoint_auth_method){\n        case undefined:\n        case \"client_secret_basic\":\n            {\n                assertNoClientPrivateKey(\"client_secret_basic\", clientPrivateKey);\n                headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n                break;\n            }\n        case \"client_secret_post\":\n            {\n                assertNoClientPrivateKey(\"client_secret_post\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_secret\", assertClientSecret(client.client_secret));\n                break;\n            }\n        case \"private_key_jwt\":\n            {\n                assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n                if (clientPrivateKey === undefined) {\n                    throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n                }\n                const { key, kid } = getKeyAndKid(clientPrivateKey);\n                if (!isPrivateKey(key)) {\n                    throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n                }\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                body.set(\"client_assertion\", await privateKeyJwt(as, client, key, kid));\n                break;\n            }\n        case \"tls_client_auth\":\n        case \"self_signed_tls_client_auth\":\n        case \"none\":\n            {\n                assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n                assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                break;\n            }\n        default:\n            throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n    }\n}\nasync function jwt(header, claimsSet, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    if (parameters.has(\"claims\")) {\n        const value = parameters.get(\"claims\");\n        if (value === \"[object Object]\") {\n            throw new OPE('\"claims\" parameter must be passed as a UTF-8 encoded JSON');\n        }\n        try {\n            claims.claims = JSON.parse(value);\n        } catch (cause) {\n            throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(claims.claims)) {\n            throw new OPE('\"claims\" parameter must be a top level object');\n        }\n    }\n    return jwt({\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const proof = await jwt({\n        alg: keyToJws(privateKey),\n        typ: \"dpop+jwt\",\n        jwk: await publicJwk(publicKey)\n    }, {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n    }, privateKey);\n    headers.set(\"dpop\", proof);\n}\nlet jwkCache;\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    if (jwkCache.has(key)) {\n        return jwkCache.get(key);\n    }\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv\n    };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nfunction validateEndpoint(value, endpoint, options) {\n    if (typeof value !== \"string\") {\n        if (options?.[experimental_useMtlsAlias]) {\n            throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n        } else {\n            throw new TypeError(`\"as.${endpoint}\" must be a string`);\n        }\n    }\n    return new URL(value);\n}\nfunction resolveEndpoint(as, endpoint, options) {\n    if (options?.[experimental_useMtlsAlias] && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, options);\n    }\n    return validateEndpoint(as[endpoint], endpoint);\n}\nasync function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"pushed_authorization_request_endpoint\", options);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nfunction isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== \"object\" || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return {\n            scheme: scheme.toLowerCase(),\n            parameters: {}\n        };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n    const parameters = {};\n    for(let i = 1; i < arr.length; i += 2){\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while(arr[idx].slice(-1) !== '\"' && ++i < arr.length){\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters\n    };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (!response.headers.has(\"www-authenticate\")) {\n        return undefined;\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)){\n        result.push([\n            scheme,\n            index\n        ]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others)=>{\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        } else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set(\"authorization\", `Bearer ${accessToken}`);\n    } else {\n        await dpopProofJwt(headers, options.DPoP, url, \"GET\", getClockSkew({\n            [clockSkew]: options?.[clockSkew]\n        }), accessToken);\n        headers.set(\"authorization\", `DPoP ${accessToken}`);\n    }\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"userinfo_endpoint\", options);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client)\n    });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    let jwks;\n    let age;\n    jwksCache || (jwksCache = new WeakMap());\n    if (jwksCache.has(as)) {\n        ;\n        ({ jwks, age } = jwksCache.get(as));\n        if (age >= 300) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        jwksCache.set(as, {\n            jwks,\n            iat: epochTime(),\n            get age () {\n                return epochTime() - this.iat;\n            }\n        });\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"EdDSA\" && !(jwk.crv === \"Ed25519\" || jwk.crv === \"Ed448\"):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE(\"error when selecting a JWT verification key, no applicable keys found\");\n    } else if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw new OPE(\"jwks_uri must only contain public keys\");\n    }\n    return key;\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE(\"JWT UserInfo Response expected\");\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    const url = resolveEndpoint(as, \"token_endpoint\", options);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, parameters, headers, options);\n}\nasync function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n    }\n    if (json.expires_in !== undefined && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n                \"aud\",\n                \"exp\",\n                \"iat\",\n                \"iss\",\n                \"sub\"\n            ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n                throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n            }\n            if (client.require_auth_time && typeof claims.auth_time !== \"number\") {\n                throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n            }\n            idTokenClaims.set(json, claims);\n        }\n    }\n    return json;\n}\nasync function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    } else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nasync function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code_verifier\", codeVerifier);\n    parameters.set(\"code\", code);\n    return tokenEndpointRequest(as, client, \"authorization_code\", parameters, options);\n}\nconst jwtClaimNames = {\n    aud: \"audience\",\n    c_hash: \"code hash\",\n    client_id: \"client id\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    jti: \"jwt id\",\n    nonce: \"nonce\",\n    s_hash: \"state hash\",\n    sub: \"subject\",\n    ath: \"access token hash\",\n    htm: \"http method\",\n    htu: \"http uri\",\n    cnf: \"confirmation\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    switch(expectedNonce){\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === \"string\" && result.id_token.length) {\n            throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nasync function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, \"revocation_endpoint\", options);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nasync function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, \"introspection_endpoint\", options);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    } else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"jwks_uri\");\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return (options?.[experimental_customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== \"string\") {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== \"string\") {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== \"string\") {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== \"string\") {\n                    delete json.scope;\n                }\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch(namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key.algorithm);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case \"Ed448\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n    if (length === 5) {\n        throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n    if (length !== 3) {\n        throw new OPE(\"Invalid JWT\");\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE(\"JWT Header must be a top level object\");\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    let key;\n    if (getKey !== noSignatureCheck) {\n        key = await getKey(header);\n        const input = `${protectedHeader}.${payload}`;\n        const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n        if (!verified) {\n            throw new OPE(\"JWT signature verification failed\");\n        }\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE(\"JWT Payload must be a top level object\");\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return {\n        header,\n        claims,\n        signature,\n        key\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(alg, data, key) {\n    let algorithm;\n    switch(alg){\n        case \"RS256\":\n        case \"PS256\":\n        case \"ES256\":\n            algorithm = \"SHA-256\";\n            break;\n        case \"RS384\":\n        case \"PS384\":\n        case \"ES384\":\n            algorithm = \"SHA-384\";\n            break;\n        case \"RS512\":\n        case \"PS512\":\n        case \"ES512\":\n            algorithm = \"SHA-512\";\n            break;\n        case \"EdDSA\":\n            if (key.algorithm.name === \"Ed25519\") {\n                algorithm = \"SHA-512\";\n                break;\n            }\n            throw new UnsupportedOperationError();\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, alg, key) {\n    const expected = await idTokenHash(alg, data, key);\n    return actual === expected;\n}\nasync function experimental_validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw new TypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams');\n    }\n    parameters = new URLSearchParams(parameters);\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    parameters.delete(\"id_token\");\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new TypeError('\"expectedState\" must be a non-empty string');\n            }\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false\n    }, client, parameters, expectedState);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!id_token) {\n        throw new OPE('\"parameters\" does not contain an ID Token');\n    }\n    const code = getURLSearchParameter(parameters, \"code\");\n    if (!code) {\n        throw new OPE('\"parameters\" does not contain an Authorization Code');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const requiredClaims = [\n        \"aud\",\n        \"exp\",\n        \"iat\",\n        \"iss\",\n        \"sub\",\n        \"nonce\",\n        \"c_hash\"\n    ];\n    if (typeof expectedState === \"string\") {\n        requiredClaims.push(\"s_hash\");\n    }\n    const { claims, header, key } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw new OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past');\n    }\n    if (typeof claims.c_hash !== \"string\" || await idTokenHashMatches(code, claims.c_hash, header.alg, key) !== true) {\n        throw new OPE('invalid ID Token \"c_hash\" (code hash) claim value');\n    }\n    if (claims.s_hash !== undefined && typeof expectedState !== \"string\") {\n        throw new OPE('could not verify ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (typeof expectedState === \"string\" && (typeof claims.s_hash !== \"string\" || await idTokenHashMatches(expectedState, claims.s_hash, header.alg, key) !== true)) {\n        throw new OPE('invalid ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (client.require_auth_time !== undefined && typeof claims.auth_time !== \"number\") {\n        throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n    }\n    if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n        throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== \"RS256\") {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, \"error_description\"),\n            error_uri: getURLSearchParameter(parameters, \"error_uri\")\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        return crv;\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg, jwk.crv), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"device_authorization_endpoint\", options);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== \"number\" || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nasync function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === \"EdDSA\" ? options?.crv ?? \"Ed25519\" : undefined);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = \"\";\n    url.hash = \"\";\n    return url.href;\n}\nasync function validateDPoP(as, request, accessTokenClaims, options) {\n    if (!request.headers.has(\"dpop\")) {\n        throw new OPE(\"operation indicated DPoP use but the request has no DPoP HTTP Header\");\n    }\n    if (request.headers.get(\"authorization\")?.toLowerCase().startsWith(\"dpop \") === false) {\n        throw new OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`);\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== \"string\") {\n        throw new OPE(\"operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim\");\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(request.headers.get(\"dpop\"), checkSigningAlgorithm.bind(undefined, undefined, as?.dpop_signing_alg_values_supported || SUPPORTED_JWS_ALGS), async ({ jwk, alg })=>{\n        if (!jwk) {\n            throw new OPE(\"DPoP Proof is missing the jwk header parameter\");\n        }\n        const key = await importJwk(alg, jwk);\n        if (key.type !== \"public\") {\n            throw new OPE(\"DPoP Proof jwk header parameter must contain a public key\");\n        }\n        return key;\n    }, clockSkew, getClockTolerance(options)).then(checkJwtType.bind(undefined, \"dpop+jwt\")).then(validatePresence.bind(undefined, [\n        \"iat\",\n        \"jti\",\n        \"ath\",\n        \"htm\",\n        \"htu\"\n    ]));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw new OPE(\"DPoP Proof iat is not recent enough\");\n    }\n    if (proof.claims.htm !== request.method) {\n        throw new OPE(\"DPoP Proof htm mismatch\");\n    }\n    if (typeof proof.claims.htu !== \"string\" || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw new OPE(\"DPoP Proof htu mismatch\");\n    }\n    {\n        const accessToken = request.headers.get(\"authorization\").split(\" \")[1];\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", encoder.encode(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw new OPE(\"DPoP Proof ath mismatch\");\n        }\n    }\n    {\n        let components;\n        switch(proof.header.jwk.kty){\n            case \"EC\":\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                    y: proof.header.jwk.y\n                };\n                break;\n            case \"OKP\":\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x\n                };\n                break;\n            case \"RSA\":\n                components = {\n                    e: proof.header.jwk.e,\n                    kty: proof.header.jwk.kty,\n                    n: proof.header.jwk.n\n                };\n                break;\n            default:\n                throw new UnsupportedOperationError();\n        }\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", encoder.encode(JSON.stringify(components))));\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw new OPE(\"JWT Access Token confirmation mismatch\");\n        }\n    }\n}\nasync function experimental_validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw new TypeError('\"request\" must be an instance of Request');\n    }\n    if (!validateString(expectedAudience)) {\n        throw new OPE('\"expectedAudience\" must be a non-empty string');\n    }\n    const authorization = request.headers.get(\"authorization\");\n    if (!authorization) {\n        throw new OPE('\"request\" is missing an Authorization HTTP Header');\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(\" \");\n    scheme = scheme.toLowerCase();\n    switch(scheme){\n        case \"dpop\":\n        case \"bearer\":\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported Authorization HTTP Header scheme\");\n    }\n    if (length !== 2) {\n        throw new OPE(\"invalid Authorization HTTP Header format\");\n    }\n    const requiredClaims = [\n        \"iss\",\n        \"exp\",\n        \"aud\",\n        \"sub\",\n        \"iat\",\n        \"jti\",\n        \"client_id\"\n    ];\n    if (options?.requireDPoP || scheme === \"dpop\" || request.headers.has(\"dpop\")) {\n        requiredClaims.push(\"cnf\");\n    }\n    const { claims } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, undefined, SUPPORTED_JWS_ALGS), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(options), getClockTolerance(options)).then(checkJwtType.bind(undefined, \"at+jwt\")).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, expectedAudience));\n    for (const claim of [\n        \"client_id\",\n        \"jti\",\n        \"sub\"\n    ]){\n        if (typeof claims[claim] !== \"string\") {\n            throw new OPE(`unexpected JWT \"${claim}\" claim type`);\n        }\n    }\n    if (\"cnf\" in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw new OPE('unexpected JWT \"cnf\" (confirmation) claim value');\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError(\"multiple confirmation claims are not supported\");\n            }\n            if (cnf !== \"jkt\") {\n                throw new UnsupportedOperationError(\"unsupported JWT Confirmation method\");\n            }\n        }\n    }\n    if (options?.requireDPoP || scheme === \"dpop\" || claims.cnf?.jkt !== undefined || request.headers.has(\"dpop\")) {\n        await validateDPoP(as, request, claims, options);\n    }\n    return claims;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0osSUFBSSxPQUFPQyxjQUFjLGVBQWUsQ0FBQ0EsVUFBVUMsU0FBUyxFQUFFQyxhQUFhLGlCQUFpQjtJQUN4RixNQUFNQyxPQUFPO0lBQ2IsTUFBTUMsVUFBVTtJQUNoQkwsYUFBYSxDQUFDLEVBQUVJLEtBQUssQ0FBQyxFQUFFQyxRQUFRLENBQUM7QUFDckM7QUFDQSxTQUFTQyxnQkFBZ0JDLEtBQUssRUFBRUMsUUFBUTtJQUNwQyxJQUFJRCxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsT0FBUUEsaUJBQWlCQyxZQUNyQkMsT0FBT0MsY0FBYyxDQUFDSCxNQUFNLENBQUNJLE9BQU9DLFdBQVcsQ0FBQyxLQUFLSixTQUFTSyxTQUFTLENBQUNGLE9BQU9DLFdBQVcsQ0FBQztJQUNuRyxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNPLE1BQU1FLFlBQVlILFNBQVM7QUFDM0IsTUFBTUksaUJBQWlCSixTQUFTO0FBQ2hDLE1BQU1LLDJCQUEyQkwsU0FBUztBQUMxQyxNQUFNTSwwQkFBMEJELHlCQUF5QjtBQUN6RCxNQUFNRSw0QkFBNEJQLFNBQVM7QUFDM0MsTUFBTVEsMkJBQTJCRCwwQkFBMEI7QUFDbEUsTUFBTUUsVUFBVSxJQUFJQztBQUNwQixNQUFNQyxVQUFVLElBQUlDO0FBQ3BCLFNBQVNDLElBQUlqQixLQUFLO0lBQ2QsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBT2EsUUFBUUssTUFBTSxDQUFDbEI7SUFDMUI7SUFDQSxPQUFPZSxRQUFRSSxNQUFNLENBQUNuQjtBQUMxQjtBQUNBLE1BQU1vQixhQUFhO0FBQ25CLFNBQVNDLGdCQUFnQnJCLEtBQUs7SUFDMUIsSUFBSUEsaUJBQWlC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TztnQkFDZixNQUFNLElBQUkxUCwwQkFBMEI7WUFDeEM7UUFDSjtJQUNKO0lBQ0EsSUFBSU0sU0FBUzZVLGVBQ1Q5SyxXQUFXLFVBQ1h2QyxPQUFPNEgsR0FBRyxFQUFFZ0YsUUFBUWhWLGFBQ3BCOFUsUUFBUXhULE9BQU8sQ0FBQ3JCLEdBQUcsQ0FBQyxTQUFTO1FBQzdCLE1BQU00VSxhQUFhN08sSUFBSThPLFNBQVMxTSxRQUFReEg7SUFDNUM7SUFDQSxPQUFPd0g7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3N5bmFwc2UtdXNlcnNlcnZpY2UvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzPzNkNDEiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFVTRVJfQUdFTlQ7XG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci51c2VyQWdlbnQ/LnN0YXJ0c1dpdGg/LignTW96aWxsYS81LjAgJykpIHtcbiAgICBjb25zdCBOQU1FID0gJ29hdXRoNHdlYmFwaSc7XG4gICAgY29uc3QgVkVSU0lPTiA9ICd2Mi44LjEnO1xuICAgIFVTRVJfQUdFTlQgPSBgJHtOQU1FfS8ke1ZFUlNJT059YDtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5zdGFuY2VPZihpbnB1dCwgZXhwZWN0ZWQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoaW5wdXQgaW5zdGFuY2VvZiBleHBlY3RlZCB8fFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBleHBlY3RlZC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBjbG9ja1NrZXcgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBjbG9ja1RvbGVyYW5jZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF9jdXN0b21GZXRjaCA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbEN1c3RvbUZldGNoID0gZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoO1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF91c2VNdGxzQWxpYXMgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWxVc2VNdGxzQWxpYXMgPSBleHBlcmltZW50YWxfdXNlTXRsc0FsaWFzO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gYnVmKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbn1cbmNvbnN0IENIVU5LX1NJWkUgPSAweDgwMDA7XG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRVcmwoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5ieXRlTGVuZ3RoOyBpICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgYXJyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dC5zdWJhcnJheShpLCBpICsgQ0hVTktfU0laRSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYXJyLmpvaW4oJycpKS5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NFVybChpbnB1dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoaW5wdXQucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnVGhlIGlucHV0IHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLicsIHsgY2F1c2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYjY0dShpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVCYXNlNjRVcmwoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0VXJsKGlucHV0KTtcbn1cbmNsYXNzIExSVSB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBsZXQgdiA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHYgPSB0aGlzLl9jYWNoZS5nZXQoa2V5KSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGtleSwgdik7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMuX2NhY2hlLmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5jYWNoZTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ29wZXJhdGlvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3BlcmF0aW9uUHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5jb25zdCBPUEUgPSBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3I7XG5jb25zdCBkcG9wTm9uY2VzID0gbmV3IExSVSgxMDApO1xuZnVuY3Rpb24gaXNDcnlwdG9LZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbnN0YW5jZW9mIENyeXB0b0tleTtcbn1cbmZ1bmN0aW9uIGlzUHJpdmF0ZUtleShrZXkpIHtcbiAgICByZXR1cm4gaXNDcnlwdG9LZXkoa2V5KSAmJiBrZXkudHlwZSA9PT0gJ3ByaXZhdGUnO1xufVxuZnVuY3Rpb24gaXNQdWJsaWNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGlzQ3J5cHRvS2V5KGtleSkgJiYga2V5LnR5cGUgPT09ICdwdWJsaWMnO1xufVxuY29uc3QgU1VQUE9SVEVEX0pXU19BTEdTID0gW1xuICAgICdQUzI1NicsXG4gICAgJ0VTMjU2JyxcbiAgICAnUlMyNTYnLFxuICAgICdQUzM4NCcsXG4gICAgJ0VTMzg0JyxcbiAgICAnUlMzODQnLFxuICAgICdQUzUxMicsXG4gICAgJ0VTNTEyJyxcbiAgICAnUlM1MTInLFxuICAgICdFZERTQScsXG5dO1xuZnVuY3Rpb24gcHJvY2Vzc0Rwb3BOb25jZShyZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcygnZHBvcC1ub25jZScpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlc3BvbnNlLnVybCk7XG4gICAgICAgICAgICBkcG9wTm9uY2VzLnNldCh1cmwub3JpZ2luLCByZXNwb25zZS5oZWFkZXJzLmdldCgnZHBvcC1ub25jZScpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR5cCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL15hcHBsaWNhdGlvblxcLy8sICcnKTtcbn1cbmZ1bmN0aW9uIGlzSnNvbk9iamVjdChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwcmVwYXJlSGVhZGVycyhpbnB1dCkge1xuICAgIGlmIChsb29zZUluc3RhbmNlT2YoaW5wdXQsIEhlYWRlcnMpKSB7XG4gICAgICAgIGlucHV0ID0gT2JqZWN0LmZyb21FbnRyaWVzKGlucHV0LmVudHJpZXMoKSk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dCk7XG4gICAgaWYgKFVTRVJfQUdFTlQgJiYgIWhlYWRlcnMuaGFzKCd1c2VyLWFnZW50JykpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ3VzZXItYWdlbnQnLCBVU0VSX0FHRU5UKTtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMuaGFzKCdhdXRob3JpemF0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmhlYWRlcnNcIiBtdXN0IG5vdCBpbmNsdWRlIHRoZSBcImF1dGhvcml6YXRpb25cIiBoZWFkZXIgbmFtZScpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuaGVhZGVyc1wiIG11c3Qgbm90IGluY2x1ZGUgdGhlIFwiZHBvcFwiIGhlYWRlciBuYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gc2lnbmFsKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5zaWduYWxcIiBtdXN0IHJldHVybiBvciBiZSBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJ5UmVxdWVzdChpc3N1ZXJJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoaXNzdWVySWRlbnRpZmllciBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpc3N1ZXJJZGVudGlmaWVyXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnKTtcbiAgICB9XG4gICAgaWYgKGlzc3VlcklkZW50aWZpZXIucHJvdG9jb2wgIT09ICdodHRwczonICYmIGlzc3VlcklkZW50aWZpZXIucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpc3N1ZXIucHJvdG9jb2xcIiBtdXN0IGJlIFwiaHR0cHM6XCIgb3IgXCJodHRwOlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaXNzdWVySWRlbnRpZmllci5ocmVmKTtcbiAgICBzd2l0Y2ggKG9wdGlvbnM/LmFsZ29yaXRobSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnb2lkYyc6XG4gICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBgJHt1cmwucGF0aG5hbWV9Ly53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYC5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2F1dGgyJzpcbiAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlcmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBgLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXIvJHt1cmwucGF0aG5hbWV9YC5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5hbGdvcml0aG1cIiBtdXN0IGJlIFwib2lkY1wiIChkZWZhdWx0KSwgb3IgXCJvYXV0aDJcIicpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIChvcHRpb25zPy5bZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIGlucHV0Lmxlbmd0aCAhPT0gMDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UoZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyLCByZXNwb25zZSkge1xuICAgIGlmICghKGV4cGVjdGVkSXNzdWVySWRlbnRpZmllciBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHBlY3RlZElzc3VlclwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIEF1dGhvcml6YXRpb24gU2VydmVyIE1ldGFkYXRhIHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5pc3N1ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaXNzdWVyXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKG5ldyBVUkwoanNvbi5pc3N1ZXIpLmhyZWYgIT09IGV4cGVjdGVkSXNzdWVySWRlbnRpZmllci5ocmVmKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaXNzdWVyXCIgZG9lcyBub3QgbWF0Y2ggXCJleHBlY3RlZElzc3VlclwiJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoKSB7XG4gICAgcmV0dXJuIGI2NHUoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllcigpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0YXRlKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tTm9uY2UoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhjb2RlVmVyaWZpZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY29kZVZlcmlmaWVyXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWYoY29kZVZlcmlmaWVyKSkpO1xufVxuZnVuY3Rpb24gZ2V0S2V5QW5kS2lkKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSB7XG4gICAgICAgIHJldHVybiB7IGtleTogaW5wdXQgfTtcbiAgICB9XG4gICAgaWYgKCEoaW5wdXQ/LmtleSBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAoaW5wdXQua2lkICE9PSB1bmRlZmluZWQgJiYgIXZhbGlkYXRlU3RyaW5nKGlucHV0LmtpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJraWRcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4geyBrZXk6IGlucHV0LmtleSwga2lkOiBpbnB1dC5raWQgfTtcbn1cbmZ1bmN0aW9uIGZvcm1VcmxFbmNvZGUodG9rZW4pIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRva2VuKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn1cbmZ1bmN0aW9uIGNsaWVudFNlY3JldEJhc2ljKGNsaWVudElkLCBjbGllbnRTZWNyZXQpIHtcbiAgICBjb25zdCB1c2VybmFtZSA9IGZvcm1VcmxFbmNvZGUoY2xpZW50SWQpO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZm9ybVVybEVuY29kZShjbGllbnRTZWNyZXQpO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gYnRvYShgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gKTtcbiAgICByZXR1cm4gYEJhc2ljICR7Y3JlZGVudGlhbHN9YDtcbn1cbmZ1bmN0aW9uIHBzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1BTMjU2JztcbiAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1BTMzg0JztcbiAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICByZXR1cm4gJ1BTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBSc2FIYXNoZWRLZXlBbGdvcml0aG0gaGFzaCBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcnNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnUlMyNTYnO1xuICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnUlMzODQnO1xuICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgIHJldHVybiAnUlM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIFJzYUhhc2hlZEtleUFsZ29yaXRobSBoYXNoIG5hbWUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkge1xuICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ0VTMjU2JztcbiAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzM4NCc7XG4gICAgICAgIGNhc2UgJ1AtNTIxJzpcbiAgICAgICAgICAgIHJldHVybiAnRVM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEVjS2V5QWxnb3JpdGhtIG5hbWVkQ3VydmUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXlUb0p3cyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZSkge1xuICAgICAgICBjYXNlICdSU0EtUFNTJzpcbiAgICAgICAgICAgIHJldHVybiBwc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdSU0FTU0EtUEtDUzEtdjFfNSc6XG4gICAgICAgICAgICByZXR1cm4gcnNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnRUNEU0EnOlxuICAgICAgICAgICAgcmV0dXJuIGVzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICBjYXNlICdFZDQ0OCc6XG4gICAgICAgICAgICByZXR1cm4gJ0VkRFNBJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBDcnlwdG9LZXkgYWxnb3JpdGhtIG5hbWUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDbG9ja1NrZXcoY2xpZW50KSB7XG4gICAgaWYgKGNsaWVudCAmJiBjbG9ja1NrZXcgaW4gY2xpZW50KSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2Nsb2NrU2tld10pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50W2Nsb2NrU2tld107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpIHtcbiAgICBpZiAoY2xpZW50ICYmIGNsb2NrVG9sZXJhbmNlIGluIGNsaWVudCkge1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBjbGllbnRbY2xvY2tUb2xlcmFuY2VdO1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRvbGVyYW5jZSkgJiYgTWF0aC5zaWduKHRvbGVyYW5jZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAzMDtcbn1cbmZ1bmN0aW9uIGVwb2NoVGltZSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG59XG5mdW5jdGlvbiBjbGllbnRBc3NlcnRpb24oYXMsIGNsaWVudCkge1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBhdWQ6IFthcy5pc3N1ZXIsIGFzLnRva2VuX2VuZHBvaW50XSxcbiAgICAgICAgZXhwOiBub3cgKyA2MCxcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIG5iZjogbm93LFxuICAgICAgICBpc3M6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgICAgIHN1YjogY2xpZW50LmNsaWVudF9pZCxcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcHJpdmF0ZUtleUp3dChhcywgY2xpZW50LCBrZXksIGtpZCkge1xuICAgIHJldHVybiBqd3Qoe1xuICAgICAgICBhbGc6IGtleVRvSndzKGtleSksXG4gICAgICAgIGtpZCxcbiAgICB9LCBjbGllbnRBc3NlcnRpb24oYXMsIGNsaWVudCksIGtleSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcyhhcykge1xuICAgIGlmICh0eXBlb2YgYXMgIT09ICdvYmplY3QnIHx8IGFzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXNcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFzLmlzc3VlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy5pc3N1ZXJcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsaWVudChjbGllbnQpIHtcbiAgICBpZiAodHlwZW9mIGNsaWVudCAhPT0gJ29iamVjdCcgfHwgY2xpZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2xpZW50XCIgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhjbGllbnQuY2xpZW50X2lkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNsaWVudC5jbGllbnRfaWRcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsaWVudFNlY3JldChjbGllbnRTZWNyZXQpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNsaWVudFNlY3JldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjbGllbnQuY2xpZW50X3NlY3JldFwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGllbnRTZWNyZXQ7XG59XG5mdW5jdGlvbiBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoY2xpZW50QXV0aE1ldGhvZCwgY2xpZW50UHJpdmF0ZUtleSkge1xuICAgIGlmIChjbGllbnRQcml2YXRlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJvcHRpb25zLmNsaWVudFByaXZhdGVLZXlcIiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBwcm92aWRlZCB3aGVuICR7Y2xpZW50QXV0aE1ldGhvZH0gY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBpcyB1c2VkLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vQ2xpZW50U2VjcmV0KGNsaWVudEF1dGhNZXRob2QsIGNsaWVudFNlY3JldCkge1xuICAgIGlmIChjbGllbnRTZWNyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImNsaWVudC5jbGllbnRfc2VjcmV0XCIgcHJvcGVydHkgbXVzdCBub3QgYmUgcHJvdmlkZWQgd2hlbiAke2NsaWVudEF1dGhNZXRob2R9IGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2QgaXMgdXNlZC5gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjbGllbnRBdXRoZW50aWNhdGlvbihhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzLCBjbGllbnRQcml2YXRlS2V5KSB7XG4gICAgYm9keS5kZWxldGUoJ2NsaWVudF9zZWNyZXQnKTtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X2Fzc2VydGlvbl90eXBlJyk7XG4gICAgYm9keS5kZWxldGUoJ2NsaWVudF9hc3NlcnRpb24nKTtcbiAgICBzd2l0Y2ggKGNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnY2xpZW50X3NlY3JldF9iYXNpYyc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnY2xpZW50X3NlY3JldF9iYXNpYycsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBjbGllbnRTZWNyZXRCYXNpYyhjbGllbnQuY2xpZW50X2lkLCBhc3NlcnRDbGllbnRTZWNyZXQoY2xpZW50LmNsaWVudF9zZWNyZXQpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjbGllbnRfc2VjcmV0X3Bvc3QnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoJ2NsaWVudF9zZWNyZXRfcG9zdCcsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9zZWNyZXQnLCBhc3NlcnRDbGllbnRTZWNyZXQoY2xpZW50LmNsaWVudF9zZWNyZXQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ByaXZhdGVfa2V5X2p3dCc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50U2VjcmV0KCdwcml2YXRlX2tleV9qd3QnLCBjbGllbnQuY2xpZW50X3NlY3JldCk7XG4gICAgICAgICAgICBpZiAoY2xpZW50UHJpdmF0ZUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmNsaWVudFByaXZhdGVLZXlcIiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gXCJjbGllbnQudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RcIiBpcyBcInByaXZhdGVfa2V5X2p3dFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQoY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBpZiAoIWlzUHJpdmF0ZUtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmNsaWVudFByaXZhdGVLZXkua2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbl90eXBlJywgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpjbGllbnQtYXNzZXJ0aW9uLXR5cGU6and0LWJlYXJlcicpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9hc3NlcnRpb24nLCBhd2FpdCBwcml2YXRlS2V5Snd0KGFzLCBjbGllbnQsIGtleSwga2lkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0bHNfY2xpZW50X2F1dGgnOlxuICAgICAgICBjYXNlICdzZWxmX3NpZ25lZF90bHNfY2xpZW50X2F1dGgnOlxuICAgICAgICBjYXNlICdub25lJzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRTZWNyZXQoY2xpZW50LnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kLCBjbGllbnQuY2xpZW50X3NlY3JldCk7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFByaXZhdGVLZXkoY2xpZW50LnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kLCBjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgY2xpZW50IHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kJyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gand0KGhlYWRlciwgY2xhaW1zU2V0LCBrZXkpIHtcbiAgICBpZiAoIWtleS51c2FnZXMuaW5jbHVkZXMoJ3NpZ24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDcnlwdG9LZXkgaW5zdGFuY2VzIHVzZWQgZm9yIHNpZ25pbmcgYXNzZXJ0aW9ucyBtdXN0IGluY2x1ZGUgXCJzaWduXCIgaW4gdGhlaXIgXCJ1c2FnZXNcIicpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGAke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpKX0uJHtiNjR1KGJ1ZihKU09OLnN0cmluZ2lmeShjbGFpbXNTZXQpKSl9YDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihrZXlUb1N1YnRsZShrZXkpLCBrZXksIGJ1ZihpbnB1dCkpKTtcbiAgICByZXR1cm4gYCR7aW5wdXR9LiR7c2lnbmF0dXJlfWA7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNzdWVSZXF1ZXN0T2JqZWN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIHByaXZhdGVLZXkpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgY29uc3QgeyBrZXksIGtpZCB9ID0gZ2V0S2V5QW5kS2lkKHByaXZhdGVLZXkpO1xuICAgIGlmICghaXNQcml2YXRlS2V5KGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwcml2YXRlS2V5LmtleVwiIG11c3QgYmUgYSBwcml2YXRlIENyeXB0b0tleScpO1xuICAgIH1cbiAgICBwYXJhbWV0ZXJzLnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICBjb25zdCBjbGFpbXMgPSB7XG4gICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhwYXJhbWV0ZXJzLmVudHJpZXMoKSksXG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgYXVkOiBhcy5pc3N1ZXIsXG4gICAgICAgIGV4cDogbm93ICsgNjAsXG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBuYmY6IG5vdyxcbiAgICAgICAgaXNzOiBjbGllbnQuY2xpZW50X2lkLFxuICAgIH07XG4gICAgbGV0IHJlc291cmNlO1xuICAgIGlmIChwYXJhbWV0ZXJzLmhhcygncmVzb3VyY2UnKSAmJlxuICAgICAgICAocmVzb3VyY2UgPSBwYXJhbWV0ZXJzLmdldEFsbCgncmVzb3VyY2UnKSkgJiZcbiAgICAgICAgcmVzb3VyY2UubGVuZ3RoID4gMSkge1xuICAgICAgICBjbGFpbXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlcnMuaGFzKCdjbGFpbXMnKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtZXRlcnMuZ2V0KCdjbGFpbXMnKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJjbGFpbXNcIiBwYXJhbWV0ZXIgbXVzdCBiZSBwYXNzZWQgYXMgYSBVVEYtOCBlbmNvZGVkIEpTT04nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xhaW1zLmNsYWltcyA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIHRoZSBcImNsYWltc1wiIHBhcmFtZXRlciBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChjbGFpbXMuY2xhaW1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJjbGFpbXNcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gand0KHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhrZXkpLFxuICAgICAgICB0eXA6ICdvYXV0aC1hdXRoei1yZXErand0JyxcbiAgICAgICAga2lkLFxuICAgIH0sIGNsYWltcywga2V5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLCB1cmwsIGh0bSwgY2xvY2tTa2V3LCBhY2Nlc3NUb2tlbikge1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5LCBub25jZSA9IGRwb3BOb25jZXMuZ2V0KHVybC5vcmlnaW4pIH0gPSBvcHRpb25zO1xuICAgIGlmICghaXNQcml2YXRlS2V5KHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5wcml2YXRlS2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgfVxuICAgIGlmICghaXNQdWJsaWNLZXkocHVibGljS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1AucHVibGljS2V5XCIgbXVzdCBiZSBhIHB1YmxpYyBDcnlwdG9LZXknKTtcbiAgICB9XG4gICAgaWYgKG5vbmNlICE9PSB1bmRlZmluZWQgJiYgIXZhbGlkYXRlU3RyaW5nKG5vbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1Aubm9uY2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKCFwdWJsaWNLZXkuZXh0cmFjdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLnB1YmxpY0tleS5leHRyYWN0YWJsZVwiIG11c3QgYmUgdHJ1ZScpO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBjb25zdCBwcm9vZiA9IGF3YWl0IGp3dCh7XG4gICAgICAgIGFsZzoga2V5VG9Kd3MocHJpdmF0ZUtleSksXG4gICAgICAgIHR5cDogJ2Rwb3Arand0JyxcbiAgICAgICAgandrOiBhd2FpdCBwdWJsaWNKd2socHVibGljS2V5KSxcbiAgICB9LCB7XG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGh0bSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGh0dTogYCR7dXJsLm9yaWdpbn0ke3VybC5wYXRobmFtZX1gLFxuICAgICAgICBhdGg6IGFjY2Vzc1Rva2VuID8gYjY0dShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGJ1ZihhY2Nlc3NUb2tlbikpKSA6IHVuZGVmaW5lZCxcbiAgICB9LCBwcml2YXRlS2V5KTtcbiAgICBoZWFkZXJzLnNldCgnZHBvcCcsIHByb29mKTtcbn1cbmxldCBqd2tDYWNoZTtcbmFzeW5jIGZ1bmN0aW9uIHB1YmxpY0p3ayhrZXkpIHtcbiAgICBqd2tDYWNoZSB8fCAoandrQ2FjaGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgICBpZiAoandrQ2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGp3a0NhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IGt0eSwgZSwgbiwgeCwgeSwgY3J2IH0gPSBhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5KTtcbiAgICBjb25zdCBqd2sgPSB7IGt0eSwgZSwgbiwgeCwgeSwgY3J2IH07XG4gICAgandrQ2FjaGUuc2V0KGtleSwgandrKTtcbiAgICByZXR1cm4gandrO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFbmRwb2ludCh2YWx1ZSwgZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3B0aW9ucz8uW2V4cGVyaW1lbnRhbF91c2VNdGxzQWxpYXNdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImFzLm10bHNfZW5kcG9pbnRfYWxpYXNlcy4ke2VuZHBvaW50fVwiIG11c3QgYmUgYSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiYXMuJHtlbmRwb2ludH1cIiBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVUkwodmFsdWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuZHBvaW50KGFzLCBlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5bZXhwZXJpbWVudGFsX3VzZU10bHNBbGlhc10gJiZcbiAgICAgICAgYXMubXRsc19lbmRwb2ludF9hbGlhc2VzICYmXG4gICAgICAgIGVuZHBvaW50IGluIGFzLm10bHNfZW5kcG9pbnRfYWxpYXNlcykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFbmRwb2ludChhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXNbZW5kcG9pbnRdLCBlbmRwb2ludCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUVuZHBvaW50KGFzW2VuZHBvaW50XSwgZW5kcG9pbnQpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAncHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdF9lbmRwb2ludCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBkcG9wUHJvb2ZKd3QoaGVhZGVycywgb3B0aW9ucy5EUG9QLCB1cmwsICdQT1NUJywgZ2V0Q2xvY2tTa2V3KGNsaWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT0F1dGgyRXJyb3IoaW5wdXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlucHV0O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmVycm9yICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHZhbHVlWzBdID09PSAnXCInICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IFNQTElUX1JFR0VYUCA9IC8oKD86LHwsICk/WzAtOWEtekEtWiEjJCUmJyorLS5eX2B8fl0rPSkvO1xuY29uc3QgU0NIRU1FU19SRUdFWFAgPSAvKD86XnwsID8pKFswLTlhLXpBLVohIyQlJicqK1xcLS5eX2B8fl0rKSg/PSR8WyAsXSkvZztcbmZ1bmN0aW9uIHd3d0F1dGgoc2NoZW1lLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhcnIgPSBwYXJhbXMuc3BsaXQoU1BMSVRfUkVHRVhQKS5zbGljZSgxKTtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1lOiBzY2hlbWUudG9Mb3dlckNhc2UoKSwgcGFyYW1ldGVyczoge30gfTtcbiAgICB9XG4gICAgYXJyW2Fyci5sZW5ndGggLSAxXSA9IGFyclthcnIubGVuZ3RoIC0gMV0ucmVwbGFjZSgvLCQvLCAnJyk7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGk7XG4gICAgICAgIGlmIChhcnJbaWR4XVswXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgd2hpbGUgKGFycltpZHhdLnNsaWNlKC0xKSAhPT0gJ1wiJyAmJiArK2kgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJyW2lkeF0gKz0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGFycltpZHggLSAxXS5yZXBsYWNlKC9eKD86LCA/KXw9JC9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcGFyYW1ldGVyc1trZXldID0gdW5xdW90ZShhcnJbaWR4XSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHBhcmFtZXRlcnMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVd3d0F1dGhlbnRpY2F0ZUNoYWxsZW5nZXMocmVzcG9uc2UpIHtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaGVhZGVycy5oYXMoJ3d3dy1hdXRoZW50aWNhdGUnKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnd3d3LWF1dGhlbnRpY2F0ZScpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgeyAxOiBzY2hlbWUsIGluZGV4IH0gb2YgaGVhZGVyLm1hdGNoQWxsKFNDSEVNRVNfUkVHRVhQKSkge1xuICAgICAgICByZXN1bHQucHVzaChbc2NoZW1lLCBpbmRleF0pO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IHJlc3VsdC5tYXAoKFtzY2hlbWUsIGluZGV4T2ZdLCBpLCBvdGhlcnMpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dCA9IG90aGVyc1tpICsgMV07XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IGhlYWRlci5zbGljZShpbmRleE9mLCBuZXh0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBoZWFkZXIuc2xpY2UoaW5kZXhPZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHd3d0F1dGgoc2NoZW1lLCBwYXJhbWV0ZXJzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbGxlbmdlcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUHVzaGVkQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAxKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBQdXNoZWQgQXV0aG9yaXphdGlvbiBSZXF1ZXN0IEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5yZXF1ZXN0X3VyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJyZXF1ZXN0X3VyaVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgbWV0aG9kLCB1cmwsIGhlYWRlcnMsIGJvZHksIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFjY2Vzc1Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFjY2Vzc1Rva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInVybFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhoZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnR0VUJywgZ2V0Q2xvY2tTa2V3KHsgW2Nsb2NrU2tld106IG9wdGlvbnM/LltjbG9ja1NrZXddIH0pLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgYERQb1AgJHthY2Nlc3NUb2tlbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIChvcHRpb25zPy5bZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1c2VySW5mb1JlcXVlc3QoYXMsIGNsaWVudCwgYWNjZXNzVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAndXNlcmluZm9fZW5kcG9pbnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vand0Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgJ0dFVCcsIHVybCwgaGVhZGVycywgbnVsbCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBbY2xvY2tTa2V3XTogZ2V0Q2xvY2tTa2V3KGNsaWVudCksXG4gICAgfSk7XG59XG5sZXQgandrc0NhY2hlO1xuYXN5bmMgZnVuY3Rpb24gZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcikge1xuICAgIGNvbnN0IHsgYWxnLCBraWQgfSA9IGhlYWRlcjtcbiAgICBjaGVja1N1cHBvcnRlZEp3c0FsZyhhbGcpO1xuICAgIGxldCBqd2tzO1xuICAgIGxldCBhZ2U7XG4gICAgandrc0NhY2hlIHx8IChqd2tzQ2FjaGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgICBpZiAoandrc0NhY2hlLmhhcyhhcykpIHtcbiAgICAgICAgO1xuICAgICAgICAoeyBqd2tzLCBhZ2UgfSA9IGp3a3NDYWNoZS5nZXQoYXMpKTtcbiAgICAgICAgaWYgKGFnZSA+PSAzMDApIHtcbiAgICAgICAgICAgIGp3a3NDYWNoZS5kZWxldGUoYXMpO1xuICAgICAgICAgICAgcmV0dXJuIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqd2tzID0gYXdhaXQgandrc1JlcXVlc3QoYXMsIG9wdGlvbnMpLnRoZW4ocHJvY2Vzc0p3a3NSZXNwb25zZSk7XG4gICAgICAgIGFnZSA9IDA7XG4gICAgICAgIGp3a3NDYWNoZS5zZXQoYXMsIHtcbiAgICAgICAgICAgIGp3a3MsXG4gICAgICAgICAgICBpYXQ6IGVwb2NoVGltZSgpLFxuICAgICAgICAgICAgZ2V0IGFnZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXBvY2hUaW1lKCkgLSB0aGlzLmlhdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQga3R5O1xuICAgIHN3aXRjaCAoYWxnLnNsaWNlKDAsIDIpKSB7XG4gICAgICAgIGNhc2UgJ1JTJzpcbiAgICAgICAgY2FzZSAnUFMnOlxuICAgICAgICAgICAga3R5ID0gJ1JTQSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRVMnOlxuICAgICAgICAgICAga3R5ID0gJ0VDJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFZCc6XG4gICAgICAgICAgICBrdHkgPSAnT0tQJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGp3a3Mua2V5cy5maWx0ZXIoKGp3aykgPT4ge1xuICAgICAgICBpZiAoandrLmt0eSAhPT0ga3R5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpZCAhPT0gdW5kZWZpbmVkICYmIGtpZCAhPT0gandrLmtpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqd2suYWxnICE9PSB1bmRlZmluZWQgJiYgYWxnICE9PSBqd2suYWxnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp3ay51c2UgIT09IHVuZGVmaW5lZCAmJiBqd2sudXNlICE9PSAnc2lnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqd2sua2V5X29wcz8uaW5jbHVkZXMoJ3ZlcmlmeScpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzI1NicgJiYgandrLmNydiAhPT0gJ1AtMjU2JzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVMzODQnICYmIGp3ay5jcnYgIT09ICdQLTM4NCc6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTNTEyJyAmJiBqd2suY3J2ICE9PSAnUC01MjEnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFZERTQScgJiYgIShqd2suY3J2ID09PSAnRWQyNTUxOScgfHwgandrLmNydiA9PT0gJ0VkNDQ4Jyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgMDogandrLCBsZW5ndGggfSA9IGNhbmRpZGF0ZXM7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgaWYgKGFnZSA+PSA2MCkge1xuICAgICAgICAgICAgandrc0NhY2hlLmRlbGV0ZShhcyk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZXJyb3Igd2hlbiBzZWxlY3RpbmcgYSBKV1QgdmVyaWZpY2F0aW9uIGtleSwgbm8gYXBwbGljYWJsZSBrZXlzIGZvdW5kJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdlcnJvciB3aGVuIHNlbGVjdGluZyBhIEpXVCB2ZXJpZmljYXRpb24ga2V5LCBtdWx0aXBsZSBhcHBsaWNhYmxlIGtleXMgZm91bmQsIGEgXCJraWRcIiBKV1QgSGVhZGVyIFBhcmFtZXRlciBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhd2FpdCBpbXBvcnRKd2soYWxnLCBqd2spO1xuICAgIGlmIChrZXkudHlwZSAhPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnandrc191cmkgbXVzdCBvbmx5IGNvbnRhaW4gcHVibGljIGtleXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3ViamVjdENoZWNrID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBnZXRDb250ZW50VHlwZShyZXNwb25zZSkge1xuICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk/LnNwbGl0KCc7JylbMF07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1VzZXJJbmZvUmVzcG9uc2UoYXMsIGNsaWVudCwgZXhwZWN0ZWRTdWJqZWN0LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBVc2VySW5mbyBFbmRwb2ludCByZXNwb25zZScpO1xuICAgIH1cbiAgICBsZXQganNvbjtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vand0Jykge1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGF3YWl0IHJlc3BvbnNlLnRleHQoKSwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMudXNlcmluZm9fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIG5vU2lnbmF0dXJlQ2hlY2ssIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlT3B0aW9uYWxJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpO1xuICAgICAgICBqc29uID0gY2xhaW1zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgVXNlckluZm8gUmVzcG9uc2UgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnN1YikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJzdWJcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3ViamVjdCkge1xuICAgICAgICBjYXNlIHNraXBTdWJqZWN0Q2hlY2s6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWRTdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiZXhwZWN0ZWRTdWJqZWN0XCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLnN1YiAhPT0gZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInJlc3BvbnNlXCIgYm9keSBcInN1YlwiIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgbWV0aG9kLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCBjbGllbnRBdXRoZW50aWNhdGlvbihhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzLCBvcHRpb25zPy5jbGllbnRQcml2YXRlS2V5KTtcbiAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgcmV0dXJuIChvcHRpb25zPy5bZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGdyYW50VHlwZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3Rva2VuX2VuZHBvaW50Jywgb3B0aW9ucyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2dyYW50X3R5cGUnLCBncmFudFR5cGUpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IGRwb3BQcm9vZkp3dChoZWFkZXJzLCBvcHRpb25zLkRQb1AsIHVybCwgJ1BPU1QnLCBnZXRDbG9ja1NrZXcoY2xpZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgcGFyYW1ldGVycywgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRva2VuR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIHJlZnJlc2hUb2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHJlZnJlc2hUb2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZWZyZXNoVG9rZW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ3JlZnJlc2hfdG9rZW4nLCByZWZyZXNoVG9rZW4pO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCAncmVmcmVzaF90b2tlbicsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuY29uc3QgaWRUb2tlbkNsYWltcyA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyhyZWYpIHtcbiAgICBpZiAoIXJlZi5pZF90b2tlbikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjbGFpbXMgPSBpZFRva2VuQ2xhaW1zLmdldChyZWYpO1xuICAgIGlmICghY2xhaW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVmXCIgd2FzIGFscmVhZHkgZ2FyYmFnZSBjb2xsZWN0ZWQgb3IgZGlkIG5vdCByZXNvbHZlIGZyb20gdGhlIHByb3BlciBzb3VyY2VzJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFpbXM7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIGlnbm9yZUlkVG9rZW4gPSBmYWxzZSwgaWdub3JlUmVmcmVzaFRva2VuID0gZmFsc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFRva2VuIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5hY2Nlc3NfdG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiYWNjZXNzX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnRva2VuX3R5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidG9rZW5fdHlwZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGpzb24udG9rZW5fdHlwZSA9IGpzb24udG9rZW5fdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChqc29uLnRva2VuX3R5cGUgIT09ICdkcG9wJyAmJiBqc29uLnRva2VuX3R5cGUgIT09ICdiZWFyZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBgdG9rZW5fdHlwZWAgdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXhwaXJlc19pbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoIWlnbm9yZVJlZnJlc2hUb2tlbiAmJlxuICAgICAgICBqc29uLnJlZnJlc2hfdG9rZW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdmFsaWRhdGVTdHJpbmcoanNvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInJlZnJlc2hfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoanNvbi5zY29wZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLnNjb3BlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInNjb3BlXCIgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIWlnbm9yZUlkVG9rZW4pIHtcbiAgICAgICAgaWYgKGpzb24uaWRfdG9rZW4gIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcoanNvbi5pZF90b2tlbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaWRfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLmlkX3Rva2VuKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoanNvbi5pZF90b2tlbiwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIG5vU2lnbmF0dXJlQ2hlY2ssIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2V4cCcsICdpYXQnLCAnaXNzJywgJ3N1YiddKSlcbiAgICAgICAgICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSAmJiBjbGFpbXMuYXVkLmxlbmd0aCAhPT0gMSAmJiBjbGFpbXMuYXpwICE9PSBjbGllbnQuY2xpZW50X2lkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF6cFwiIChhdXRob3JpemVkIHBhcnR5KSBjbGFpbSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSAmJiB0eXBlb2YgY2xhaW1zLmF1dGhfdGltZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zLnNldChqc29uLCBjbGFpbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5hdWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdC5jbGFpbXMuYXVkKSkge1xuICAgICAgICBpZiAoIXJlc3VsdC5jbGFpbXMuYXVkLmluY2x1ZGVzKGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0LmNsYWltcy5hdWQgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbElzc3VlcihleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuaXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlSXNzdWVyKGV4cGVjdGVkLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJc3N1ZXIoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmlzcyAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgYnJhbmRlZCA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBicmFuZChzZWFyY2hQYXJhbXMpIHtcbiAgICBicmFuZGVkLmFkZChzZWFyY2hQYXJhbXMpO1xuICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aG9yaXphdGlvbkNvZGVHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2FsbGJhY2tQYXJhbWV0ZXJzLCByZWRpcmVjdFVyaSwgY29kZVZlcmlmaWVyLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghYnJhbmRlZC5oYXMoY2FsbGJhY2tQYXJhbWV0ZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrUGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zIG9idGFpbmVkIGZyb20gXCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSgpXCIsIG9yIFwidmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoKScpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHJlZGlyZWN0VXJpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZGlyZWN0VXJpXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhjb2RlVmVyaWZpZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY29kZVZlcmlmaWVyXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihjYWxsYmFja1BhcmFtZXRlcnMsICdjb2RlJyk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ25vIGF1dGhvcml6YXRpb24gY29kZSBpbiBcImNhbGxiYWNrUGFyYW1ldGVyc1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgncmVkaXJlY3RfdXJpJywgcmVkaXJlY3RVcmkpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlX3ZlcmlmaWVyJywgY29kZVZlcmlmaWVyKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnY29kZScsIGNvZGUpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCAnYXV0aG9yaXphdGlvbl9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5jb25zdCBqd3RDbGFpbU5hbWVzID0ge1xuICAgIGF1ZDogJ2F1ZGllbmNlJyxcbiAgICBjX2hhc2g6ICdjb2RlIGhhc2gnLFxuICAgIGNsaWVudF9pZDogJ2NsaWVudCBpZCcsXG4gICAgZXhwOiAnZXhwaXJhdGlvbiB0aW1lJyxcbiAgICBpYXQ6ICdpc3N1ZWQgYXQnLFxuICAgIGlzczogJ2lzc3VlcicsXG4gICAganRpOiAnand0IGlkJyxcbiAgICBub25jZTogJ25vbmNlJyxcbiAgICBzX2hhc2g6ICdzdGF0ZSBoYXNoJyxcbiAgICBzdWI6ICdzdWJqZWN0JyxcbiAgICBhdGg6ICdhY2Nlc3MgdG9rZW4gaGFzaCcsXG4gICAgaHRtOiAnaHR0cCBtZXRob2QnLFxuICAgIGh0dTogJ2h0dHAgdXJpJyxcbiAgICBjbmY6ICdjb25maXJtYXRpb24nLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJlc2VuY2UocmVxdWlyZWQsIHJlc3VsdCkge1xuICAgIGZvciAoY29uc3QgY2xhaW0gb2YgcmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5jbGFpbXNbY2xhaW1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoYEpXVCBcIiR7Y2xhaW19XCIgKCR7and0Q2xhaW1OYW1lc1tjbGFpbV19KSBjbGFpbSBtaXNzaW5nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCBleHBlY3ROb05vbmNlID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3Qgc2tpcEF1dGhUaW1lQ2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgbWF4QWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVzdWx0LmlkX3Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlkX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgbWF4QWdlID8/IChtYXhBZ2UgPSBjbGllbnQuZGVmYXVsdF9tYXhfYWdlID8/IHNraXBBdXRoVGltZUNoZWNrKTtcbiAgICBjb25zdCBjbGFpbXMgPSBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlc3VsdCk7XG4gICAgaWYgKChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgfHwgbWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykgJiZcbiAgICAgICAgY2xhaW1zLmF1dGhfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0lEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInIHx8IG1heEFnZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5tYXhfYWdlXCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIG1heEFnZSA8IG5vdyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWROb25jZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBleHBlY3ROb05vbmNlOlxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZE5vbmNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWROb25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhaW1zLm5vbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gZXhwZWN0ZWROb25jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHRydWUpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5pZF90b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmlkX3Rva2VuID09PSAnc3RyaW5nJyAmJiByZXN1bHQuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdVbmV4cGVjdGVkIElEIFRva2VuIHJldHVybmVkLCB1c2UgcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UoKSBmb3IgT3BlbklEIENvbm5lY3QgY2FsbGJhY2sgcHJvY2Vzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaWRfdG9rZW47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGVja0p3dFR5cGUoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0LmhlYWRlci50eXAgIT09ICdzdHJpbmcnIHx8IG5vcm1hbGl6ZVR5cChyZXN1bHQuaGVhZGVyLnR5cCkgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwidHlwXCIgaGVhZGVyIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdjbGllbnRfY3JlZGVudGlhbHMnLCBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldm9jYXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widG9rZW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdyZXZvY2F0aW9uX2VuZHBvaW50Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5kZWxldGUoJ2FjY2VwdCcpO1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Jldm9jYXRpb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBSZXZvY2F0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBib2R5IGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRyb3NwZWN0aW9uUmVxdWVzdChhcywgY2xpZW50LCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAnaW50cm9zcGVjdGlvbl9lbmRwb2ludCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zPy5yZXF1ZXN0Snd0UmVzcG9uc2UgPz8gY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL3Rva2VuLWludHJvc3BlY3Rpb24rand0Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW50cm9zcGVjdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBJbnRyb3NwZWN0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi90b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpIHtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhd2FpdCByZXNwb25zZS50ZXh0KCksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICd0b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnaWF0JywgJ2lzcyddKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgICAgICBqc29uID0gY2xhaW1zLnRva2VuX2ludHJvc3BlY3Rpb247XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgXCJ0b2tlbl9pbnRyb3NwZWN0aW9uXCIgY2xhaW0gbXVzdCBiZSBhIEpTT04gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uYWN0aXZlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJhY3RpdmVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ2p3a3NfdXJpJyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGhlYWRlcnMuYXBwZW5kKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vandrLXNldCtqc29uJyk7XG4gICAgcmV0dXJuIChvcHRpb25zPy5bZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzSndrc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gSlNPTiBXZWIgS2V5IFNldCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5rZXlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkucHJvdG90eXBlLmV2ZXJ5LmNhbGwoanNvbi5rZXlzLCBpc0pzb25PYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwia2V5c1wiIHByb3BlcnR5IG1lbWJlcnMgbXVzdCBiZSBKV0sgZm9ybWF0dGVkIG9iamVjdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAzOTkgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25PYmplY3QoanNvbikgJiYgdHlwZW9mIGpzb24uZXJyb3IgPT09ICdzdHJpbmcnICYmIGpzb24uZXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3JfZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5lcnJvcl9kZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uLmVycm9yX3VyaSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLmVycm9yX3VyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXJyb3JfdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5hbGdzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uYWxncyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uYWxncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uc2NvcGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5zY29wZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWRKd3NBbGcoYWxnKSB7XG4gICAgaWYgKCFTVVBQT1JURURfSldTX0FMR1MuaW5jbHVkZXMoYWxnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldTIFwiYWxnXCIgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICByZXR1cm4gYWxnO1xufVxuZnVuY3Rpb24gY2hlY2tSc2FLZXlBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAhPT0gJ251bWJlcicgfHwgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPCAyMDQ4KSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoYCR7YWxnb3JpdGhtLm5hbWV9IG1vZHVsdXNMZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAyMDQ4IGJpdHNgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlY2RzYUhhc2hOYW1lKG5hbWVkQ3VydmUpIHtcbiAgICBzd2l0Y2ggKG5hbWVkQ3VydmUpIHtcbiAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtMjU2JztcbiAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9TdWJ0bGUoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnRUNEU0EnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICAgICAgaGFzaDogZWNkc2FIYXNoTmFtZShrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6IHtcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LmFsZ29yaXRobS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FsdExlbmd0aDogcGFyc2VJbnQoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUuc2xpY2UoLTMpLCAxMCkgPj4gMyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgcmV0dXJuIGtleS5hbGdvcml0aG0ubmFtZTtcbiAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG59XG5jb25zdCBub1NpZ25hdHVyZUNoZWNrID0gU3ltYm9sKCk7XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3dChqd3MsIGNoZWNrQWxnLCBnZXRLZXksIGNsb2NrU2tldywgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSwgbGVuZ3RoIH0gPSBqd3Muc3BsaXQoJy4nKTtcbiAgICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdKV0Ugc3RydWN0dXJlIEpXVHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdJbnZhbGlkIEpXVCcpO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyO1xuICAgIHRyeSB7XG4gICAgICAgIGhlYWRlciA9IEpTT04ucGFyc2UoYnVmKGI2NHUocHJvdGVjdGVkSGVhZGVyKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBIZWFkZXIgYm9keSBhcyBiYXNlNjR1cmwgZW5jb2RlZCBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoaGVhZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgSGVhZGVyIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNoZWNrQWxnKGhlYWRlcik7XG4gICAgaWYgKGhlYWRlci5jcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJjcml0XCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGxldCBrZXk7XG4gICAgaWYgKGdldEtleSAhPT0gbm9TaWduYXR1cmVDaGVjaykge1xuICAgICAgICBrZXkgPSBhd2FpdCBnZXRLZXkoaGVhZGVyKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBgJHtwcm90ZWN0ZWRIZWFkZXJ9LiR7cGF5bG9hZH1gO1xuICAgICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KGtleVRvU3VidGxlKGtleSksIGtleSwgc2lnbmF0dXJlLCBidWYoaW5wdXQpKTtcbiAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNsYWltcztcbiAgICB0cnkge1xuICAgICAgICBjbGFpbXMgPSBKU09OLnBhcnNlKGJ1ZihiNjR1KHBheWxvYWQpKSk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgSldUIFBheWxvYWQgYm9keSBhcyBiYXNlNjR1cmwgZW5jb2RlZCBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoY2xhaW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgUGF5bG9hZCBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBpZiAoY2xhaW1zLmV4cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiZXhwXCIgKGV4cGlyYXRpb24gdGltZSkgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMuZXhwIDw9IG5vdyAtIGNsb2NrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImV4cFwiIChleHBpcmF0aW9uIHRpbWUpIGNsYWltIHZhbHVlLCB0aW1lc3RhbXAgaXMgPD0gbm93KCknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmlhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmlhdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaWF0XCIgKGlzc3VlZCBhdCkgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuaXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuaXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5uYmYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5uYmYgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcIm5iZlwiIChub3QgYmVmb3JlKSBjbGFpbSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5uYmYgPiBub3cgKyBjbG9ja1RvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gdmFsdWUsIHRpbWVzdGFtcCBpcyA+IG5vdygpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5hdWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5hdWQgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGNsYWltcy5hdWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGhlYWRlciwgY2xhaW1zLCBzaWduYXR1cmUsIGtleSB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcywgb3IgVVJMJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdyZXNwb25zZScpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJwYXJhbWV0ZXJzXCIgZG9lcyBub3QgY29udGFpbiBhIEpBUk0gcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcy5qd2tzX3VyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhcy5qd2tzX3VyaVwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KHJlc3BvbnNlLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5hdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmF1dGhvcml6YXRpb25fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCksIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpLmJpbmQodW5kZWZpbmVkLCBhcywgb3B0aW9ucyksIGdldENsb2NrU2tldyhjbGllbnQpLCBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2F1ZCcsICdleHAnLCAnaXNzJ10pKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjbGFpbXMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGtleSAhPT0gJ2F1ZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlQXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3VsdCwgZXhwZWN0ZWRTdGF0ZSk7XG59XG5hc3luYyBmdW5jdGlvbiBpZFRva2VuSGFzaChhbGcsIGRhdGEsIGtleSkge1xuICAgIGxldCBhbGdvcml0aG07XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICBjYXNlICdQUzI1Nic6XG4gICAgICAgIGNhc2UgJ0VTMjU2JzpcbiAgICAgICAgICAgIGFsZ29yaXRobSA9ICdTSEEtMjU2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSUzM4NCc6XG4gICAgICAgIGNhc2UgJ1BTMzg0JzpcbiAgICAgICAgY2FzZSAnRVMzODQnOlxuICAgICAgICAgICAgYWxnb3JpdGhtID0gJ1NIQS0zODQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTNTEyJzpcbiAgICAgICAgY2FzZSAnUFM1MTInOlxuICAgICAgICBjYXNlICdFUzUxMic6XG4gICAgICAgICAgICBhbGdvcml0aG0gPSAnU0hBLTUxMic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRWREU0EnOlxuICAgICAgICAgICAgaWYgKGtleS5hbGdvcml0aG0ubmFtZSA9PT0gJ0VkMjU1MTknKSB7XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtID0gJ1NIQS01MTInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgYnVmKGRhdGEpKTtcbiAgICByZXR1cm4gYjY0dShkaWdlc3Quc2xpY2UoMCwgZGlnZXN0LmJ5dGVMZW5ndGggLyAyKSk7XG59XG5hc3luYyBmdW5jdGlvbiBpZFRva2VuSGFzaE1hdGNoZXMoZGF0YSwgYWN0dWFsLCBhbGcsIGtleSkge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYXdhaXQgaWRUb2tlbkhhc2goYWxnLCBkYXRhLCBrZXkpO1xuICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGVyaW1lbnRhbF92YWxpZGF0ZURldGFjaGVkU2lnbmF0dXJlUmVzcG9uc2UoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWROb25jZSwgZXhwZWN0ZWRTdGF0ZSwgbWF4QWdlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIGlmICghcGFyYW1ldGVycy5oYXNoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgYXMgYW4gaW5zdGFuY2Ugb2YgVVJMIG11c3QgY29udGFpbiBhIGhhc2ggKGZyYWdtZW50KSB3aXRoIHRoZSBBdXRob3JpemF0aW9uIFJlc3BvbnNlIHBhcmFtZXRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzLmhhc2guc2xpY2UoMSkpO1xuICAgIH1cbiAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcycpO1xuICAgIH1cbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBpZF90b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaWRfdG9rZW4nKTtcbiAgICBwYXJhbWV0ZXJzLmRlbGV0ZSgnaWRfdG9rZW4nKTtcbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9TdGF0ZTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWRTdGF0ZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlQXV0aFJlc3BvbnNlKHtcbiAgICAgICAgLi4uYXMsXG4gICAgICAgIGF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIH0sIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWRTdGF0ZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIWlkX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicGFyYW1ldGVyc1wiIGRvZXMgbm90IGNvbnRhaW4gYW4gSUQgVG9rZW4nKTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnY29kZScpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGFuIEF1dGhvcml6YXRpb24gQ29kZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFzLmp3a3NfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmp3a3NfdXJpXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlZENsYWltcyA9IFtcbiAgICAgICAgJ2F1ZCcsXG4gICAgICAgICdleHAnLFxuICAgICAgICAnaWF0JyxcbiAgICAgICAgJ2lzcycsXG4gICAgICAgICdzdWInLFxuICAgICAgICAnbm9uY2UnLFxuICAgICAgICAnY19oYXNoJyxcbiAgICBdO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRTdGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCgnc19oYXNoJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhaW1zLCBoZWFkZXIsIGtleSB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoaWRfdG9rZW4sIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGcsIGFzLmlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpLCBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaS5iaW5kKHVuZGVmaW5lZCwgYXMsIG9wdGlvbnMpLCBnZXRDbG9ja1NrZXcoY2xpZW50KSwgZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgcmVxdWlyZWRDbGFpbXMpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgIGNvbnN0IGNsb2NrU2tldyA9IGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGlmIChjbGFpbXMuaWF0IDwgbm93IC0gMzYwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlhdFwiIChpc3N1ZWQgYXQpIGNsYWltIHZhbHVlLCBpdCBpcyB0b28gZmFyIGluIHRoZSBwYXN0Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xhaW1zLmNfaGFzaCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKGF3YWl0IGlkVG9rZW5IYXNoTWF0Y2hlcyhjb2RlLCBjbGFpbXMuY19oYXNoLCBoZWFkZXIuYWxnLCBrZXkpKSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdpbnZhbGlkIElEIFRva2VuIFwiY19oYXNoXCIgKGNvZGUgaGFzaCkgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKGNsYWltcy5zX2hhc2ggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXhwZWN0ZWRTdGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnY291bGQgbm90IHZlcmlmeSBJRCBUb2tlbiBcInNfaGFzaFwiIChzdGF0ZSBoYXNoKSBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkU3RhdGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICh0eXBlb2YgY2xhaW1zLnNfaGFzaCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChhd2FpdCBpZFRva2VuSGFzaE1hdGNoZXMoZXhwZWN0ZWRTdGF0ZSwgY2xhaW1zLnNfaGFzaCwgaGVhZGVyLmFsZywga2V5KSkgIT09IHRydWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ludmFsaWQgSUQgVG9rZW4gXCJzX2hhc2hcIiAoc3RhdGUgaGFzaCkgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjbGFpbXMuYXV0aF90aW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIG1heEFnZSA/PyAobWF4QWdlID0gY2xpZW50LmRlZmF1bHRfbWF4X2FnZSA/PyBza2lwQXV0aFRpbWVDaGVjayk7XG4gICAgaWYgKChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgfHwgbWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykgJiZcbiAgICAgICAgY2xhaW1zLmF1dGhfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0lEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInIHx8IG1heEFnZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5tYXhfYWdlXCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIG1heEFnZSA8IG5vdyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoZXhwZWN0ZWROb25jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHBlY3RlZE5vbmNlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGNsYWltcy5ub25jZSAhPT0gZXhwZWN0ZWROb25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwibm9uY2VcIiBjbGFpbSB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSAmJiBjbGFpbXMuYXVkLmxlbmd0aCAhPT0gMSAmJiBjbGFpbXMuYXpwICE9PSBjbGllbnQuY2xpZW50X2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhenBcIiAoYXV0aG9yaXplZCBwYXJ0eSkgY2xhaW0gdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbmluZ0FsZ29yaXRobShjbGllbnQsIGlzc3VlciwgaGVhZGVyKSB7XG4gICAgaWYgKGNsaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChoZWFkZXIuYWxnICE9PSBjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXNzdWVyKSkge1xuICAgICAgICBpZiAoIWlzc3Vlci5pbmNsdWRlcyhoZWFkZXIuYWxnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gJ1JTMjU2Jykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgbmFtZSkge1xuICAgIGNvbnN0IHsgMDogdmFsdWUsIGxlbmd0aCB9ID0gcGFyYW1ldGVycy5nZXRBbGwobmFtZSk7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRShgXCIke25hbWV9XCIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgb25seSBvbmNlYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3RhdGVDaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVjdE5vU3RhdGUgPSBTeW1ib2woKTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMsIG9yIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdyZXNwb25zZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicGFyYW1ldGVyc1wiIGNvbnRhaW5zIGEgSkFSTSByZXNwb25zZSwgdXNlIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKCkgaW5zdGVhZCBvZiB2YWxpZGF0ZUF1dGhSZXNwb25zZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzcyA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaXNzJyk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3N0YXRlJyk7XG4gICAgaWYgKCFpc3MgJiYgYXMuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdyZXNwb25zZSBwYXJhbWV0ZXIgXCJpc3NcIiAoaXNzdWVyKSBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmIChpc3MgJiYgaXNzICE9PSBhcy5pc3N1ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcImlzc1wiIChpc3N1ZXIpIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9TdGF0ZTpcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIGVuY291bnRlcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBza2lwU3RhdGVDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiZXhwZWN0ZWRTdGF0ZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3Jlc3BvbnNlIHBhcmFtZXRlciBcInN0YXRlXCIgbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcicpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvcl9kZXNjcmlwdGlvbjogZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcl9kZXNjcmlwdGlvbicpLFxuICAgICAgICAgICAgZXJyb3JfdXJpOiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2Vycm9yX3VyaScpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpZF90b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaWRfdG9rZW4nKTtcbiAgICBjb25zdCB0b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAndG9rZW4nKTtcbiAgICBpZiAoaWRfdG9rZW4gIT09IHVuZGVmaW5lZCB8fCB0b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdpbXBsaWNpdCBhbmQgaHlicmlkIGZsb3dzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBicmFuZChuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpKTtcbn1cbmZ1bmN0aW9uIGFsZ1RvU3VidGxlKGFsZywgY3J2KSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUFMyNTYnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0EtUFNTJywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1JTMzg0JzpcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6IGBQLSR7YWxnLnNsaWNlKC0zKX1gIH07XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6ICdQLTUyMScgfTtcbiAgICAgICAgY2FzZSAnRWREU0EnOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNydikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNydjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEp3ayhhbGcsIGp3aykge1xuICAgIGNvbnN0IHsgZXh0LCBrZXlfb3BzLCB1c2UsIC4uLmtleSB9ID0gandrO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywga2V5LCBhbGdUb1N1YnRsZShhbGcsIGp3ay5jcnYpLCB0cnVlLCBbJ3ZlcmlmeSddKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXZpY2VBdXRob3JpemF0aW9uUmVxdWVzdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ2RldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIERldmljZSBBdXRob3JpemF0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5kZXZpY2VfY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJkZXZpY2VfY29kZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi51c2VyX2NvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidXNlcl9jb2RlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnZlcmlmaWNhdGlvbl91cmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidmVyaWZpY2F0aW9uX3VyaVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdmFsaWRhdGVTdHJpbmcoanNvbi52ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInZlcmlmaWNhdGlvbl91cmlfY29tcGxldGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoanNvbi5pbnRlcnZhbCAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YganNvbi5pbnRlcnZhbCAhPT0gJ251bWJlcicgfHwganNvbi5pbnRlcnZhbCA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImludGVydmFsXCIgcHJvcGVydHkgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXZpY2VDb2RlR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGRldmljZUNvZGUsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhkZXZpY2VDb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRldmljZUNvZGVcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2RldmljZV9jb2RlJywgZGV2aWNlQ29kZSk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpkZXZpY2VfY29kZScsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEZXZpY2VDb2RlUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUtleVBhaXIoYWxnLCBvcHRpb25zKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhhbGcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxnXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYWxnb3JpdGhtID0gYWxnVG9TdWJ0bGUoYWxnLCBhbGcgPT09ICdFZERTQScgPyBvcHRpb25zPy5jcnYgPz8gJ0VkMjU1MTknIDogdW5kZWZpbmVkKTtcbiAgICBpZiAoYWxnLnN0YXJ0c1dpdGgoJ1BTJykgfHwgYWxnLnN0YXJ0c1dpdGgoJ1JTJykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbGdvcml0aG0sIHtcbiAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IG9wdGlvbnM/Lm1vZHVsdXNMZW5ndGggPz8gMjA0OCxcbiAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBuZXcgVWludDhBcnJheShbMHgwMSwgMHgwMCwgMHgwMV0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KGFsZ29yaXRobSwgb3B0aW9ucz8uZXh0cmFjdGFibGUgPz8gZmFsc2UsIFsnc2lnbicsICd2ZXJpZnknXSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSHR1KGh0dSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHR1KTtcbiAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgdXJsLmhhc2ggPSAnJztcbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZURQb1AoYXMsIHJlcXVlc3QsIGFjY2Vzc1Rva2VuQ2xhaW1zLCBvcHRpb25zKSB7XG4gICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnMuaGFzKCdkcG9wJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnb3BlcmF0aW9uIGluZGljYXRlZCBEUG9QIHVzZSBidXQgdGhlIHJlcXVlc3QgaGFzIG5vIERQb1AgSFRUUCBIZWFkZXInKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKT8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdkcG9wICcpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKGBvcGVyYXRpb24gaW5kaWNhdGVkIERQb1AgdXNlIGJ1dCB0aGUgcmVxdWVzdCdzIEF1dGhvcml6YXRpb24gSFRUUCBIZWFkZXIgc2NoZW1lIGlzIG5vdCBEUG9QYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWNjZXNzVG9rZW5DbGFpbXMuY25mPy5qa3QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ29wZXJhdGlvbiBpbmRpY2F0ZWQgRFBvUCB1c2UgYnV0IHRoZSBKV1QgQWNjZXNzIFRva2VuIGhhcyBubyBqa3QgY29uZmlybWF0aW9uIGNsYWltJyk7XG4gICAgfVxuICAgIGNvbnN0IGNsb2NrU2tldyA9IGdldENsb2NrU2tldyhvcHRpb25zKTtcbiAgICBjb25zdCBwcm9vZiA9IGF3YWl0IHZhbGlkYXRlSnd0KHJlcXVlc3QuaGVhZGVycy5nZXQoJ2Rwb3AnKSwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCB1bmRlZmluZWQsIGFzPy5kcG9wX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQgfHwgU1VQUE9SVEVEX0pXU19BTEdTKSwgYXN5bmMgKHsgandrLCBhbGcgfSkgPT4ge1xuICAgICAgICBpZiAoIWp3aykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnRFBvUCBQcm9vZiBpcyBtaXNzaW5nIHRoZSBqd2sgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IGltcG9ydEp3ayhhbGcsIGp3ayk7XG4gICAgICAgIGlmIChrZXkudHlwZSAhPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0RQb1AgUHJvb2YgandrIGhlYWRlciBwYXJhbWV0ZXIgbXVzdCBjb250YWluIGEgcHVibGljIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfSwgY2xvY2tTa2V3LCBnZXRDbG9ja1RvbGVyYW5jZShvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oY2hlY2tKd3RUeXBlLmJpbmQodW5kZWZpbmVkLCAnZHBvcCtqd3QnKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydpYXQnLCAnanRpJywgJ2F0aCcsICdodG0nLCAnaHR1J10pKTtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGNsb2NrU2tldztcbiAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMobm93IC0gcHJvb2YuY2xhaW1zLmlhdCk7XG4gICAgaWYgKGRpZmYgPiAzMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnRFBvUCBQcm9vZiBpYXQgaXMgbm90IHJlY2VudCBlbm91Z2gnKTtcbiAgICB9XG4gICAgaWYgKHByb29mLmNsYWltcy5odG0gIT09IHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0RQb1AgUHJvb2YgaHRtIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvb2YuY2xhaW1zLmh0dSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgbm9ybWFsaXplSHR1KHByb29mLmNsYWltcy5odHUpICE9PSBub3JtYWxpemVIdHUocmVxdWVzdC51cmwpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0RQb1AgUHJvb2YgaHR1IG1pc21hdGNoJyk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJykuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZW5jb2Rlci5lbmNvZGUoYWNjZXNzVG9rZW4pKSk7XG4gICAgICAgIGlmIChwcm9vZi5jbGFpbXMuYXRoICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnRFBvUCBQcm9vZiBhdGggbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIGxldCBjb21wb25lbnRzO1xuICAgICAgICBzd2l0Y2ggKHByb29mLmhlYWRlci5qd2sua3R5KSB7XG4gICAgICAgICAgICBjYXNlICdFQyc6XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3J2OiBwcm9vZi5oZWFkZXIuandrLmNydixcbiAgICAgICAgICAgICAgICAgICAga3R5OiBwcm9vZi5oZWFkZXIuandrLmt0eSxcbiAgICAgICAgICAgICAgICAgICAgeDogcHJvb2YuaGVhZGVyLmp3ay54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwcm9vZi5oZWFkZXIuandrLnksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ09LUCc6XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3J2OiBwcm9vZi5oZWFkZXIuandrLmNydixcbiAgICAgICAgICAgICAgICAgICAga3R5OiBwcm9vZi5oZWFkZXIuandrLmt0eSxcbiAgICAgICAgICAgICAgICAgICAgeDogcHJvb2YuaGVhZGVyLmp3ay54LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdSU0EnOlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGU6IHByb29mLmhlYWRlci5qd2suZSxcbiAgICAgICAgICAgICAgICAgICAga3R5OiBwcm9vZi5oZWFkZXIuandrLmt0eSxcbiAgICAgICAgICAgICAgICAgICAgbjogcHJvb2YuaGVhZGVyLmp3ay5uLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50cykpKSk7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbkNsYWltcy5jbmYuamt0ICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIEFjY2VzcyBUb2tlbiBjb25maXJtYXRpb24gbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBlcmltZW50YWxfdmFsaWRhdGVKd3RBY2Nlc3NUb2tlbihhcywgcmVxdWVzdCwgZXhwZWN0ZWRBdWRpZW5jZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXF1ZXN0LCBSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlcXVlc3RcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlcXVlc3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZEF1ZGllbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImV4cGVjdGVkQXVkaWVuY2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBhdXRob3JpemF0aW9uID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aG9yaXphdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlcXVlc3RcIiBpcyBtaXNzaW5nIGFuIEF1dGhvcml6YXRpb24gSFRUUCBIZWFkZXInKTtcbiAgICB9XG4gICAgbGV0IHsgMDogc2NoZW1lLCAxOiBhY2Nlc3NUb2tlbiwgbGVuZ3RoIH0gPSBhdXRob3JpemF0aW9uLnNwbGl0KCcgJyk7XG4gICAgc2NoZW1lID0gc2NoZW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgY2FzZSAnZHBvcCc6XG4gICAgICAgIGNhc2UgJ2JlYXJlcic6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyIHNjaGVtZScpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ludmFsaWQgQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlciBmb3JtYXQnKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRDbGFpbXMgPSBbXG4gICAgICAgICdpc3MnLFxuICAgICAgICAnZXhwJyxcbiAgICAgICAgJ2F1ZCcsXG4gICAgICAgICdzdWInLFxuICAgICAgICAnaWF0JyxcbiAgICAgICAgJ2p0aScsXG4gICAgICAgICdjbGllbnRfaWQnLFxuICAgIF07XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVpcmVEUG9QIHx8IHNjaGVtZSA9PT0gJ2Rwb3AnIHx8IHJlcXVlc3QuaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICByZXF1aXJlZENsYWltcy5wdXNoKCdjbmYnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbGFpbXMgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGFjY2Vzc1Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgU1VQUE9SVEVEX0pXU19BTEdTKSwgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkuYmluZCh1bmRlZmluZWQsIGFzLCBvcHRpb25zKSwgZ2V0Q2xvY2tTa2V3KG9wdGlvbnMpLCBnZXRDbG9ja1RvbGVyYW5jZShvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oY2hlY2tKd3RUeXBlLmJpbmQodW5kZWZpbmVkLCAnYXQrand0JykpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIHJlcXVpcmVkQ2xhaW1zKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzLmlzc3VlcikpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGV4cGVjdGVkQXVkaWVuY2UpKTtcbiAgICBmb3IgKGNvbnN0IGNsYWltIG9mIFsnY2xpZW50X2lkJywgJ2p0aScsICdzdWInXSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltc1tjbGFpbV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKGB1bmV4cGVjdGVkIEpXVCBcIiR7Y2xhaW19XCIgY2xhaW0gdHlwZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnY25mJyBpbiBjbGFpbXMpIHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoY2xhaW1zLmNuZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiY25mXCIgKGNvbmZpcm1hdGlvbikgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IDA6IGNuZiwgbGVuZ3RoIH0gPSBPYmplY3Qua2V5cyhjbGFpbXMuY25mKTtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdtdWx0aXBsZSBjb25maXJtYXRpb24gY2xhaW1zIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY25mICE9PSAnamt0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBKV1QgQ29uZmlybWF0aW9uIG1ldGhvZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5yZXF1aXJlRFBvUCB8fFxuICAgICAgICBzY2hlbWUgPT09ICdkcG9wJyB8fFxuICAgICAgICBjbGFpbXMuY25mPy5qa3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuaGFzKCdkcG9wJykpIHtcbiAgICAgICAgYXdhaXQgdmFsaWRhdGVEUG9QKGFzLCByZXF1ZXN0LCBjbGFpbXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhaW1zO1xufVxuIl0sIm5hbWVzIjpbIlVTRVJfQUdFTlQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdGFydHNXaXRoIiwiTkFNRSIsIlZFUlNJT04iLCJsb29zZUluc3RhbmNlT2YiLCJpbnB1dCIsImV4cGVjdGVkIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInByb3RvdHlwZSIsImNsb2NrU2tldyIsImNsb2NrVG9sZXJhbmNlIiwiZXhwZXJpbWVudGFsX2N1c3RvbUZldGNoIiwiZXhwZXJpbWVudGFsQ3VzdG9tRmV0Y2giLCJleHBlcmltZW50YWxfdXNlTXRsc0FsaWFzIiwiZXhwZXJpbWVudGFsVXNlTXRsc0FsaWFzIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmIiwiZW5jb2RlIiwiZGVjb2RlIiwiQ0hVTktfU0laRSIsImVuY29kZUJhc2U2NFVybCIsIkFycmF5QnVmZmVyIiwiVWludDhBcnJheSIsImFyciIsImkiLCJieXRlTGVuZ3RoIiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5Iiwic3ViYXJyYXkiLCJidG9hIiwiam9pbiIsInJlcGxhY2UiLCJkZWNvZGVCYXNlNjRVcmwiLCJiaW5hcnkiLCJhdG9iIiwiYnl0ZXMiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY2F1c2UiLCJPUEUiLCJiNjR1IiwiTFJVIiwiY29uc3RydWN0b3IiLCJtYXhTaXplIiwiY2FjaGUiLCJNYXAiLCJfY2FjaGUiLCJnZXQiLCJrZXkiLCJ2IiwidXBkYXRlIiwidW5kZWZpbmVkIiwiaGFzIiwic2V0IiwidmFsdWUiLCJkZWxldGUiLCJzaXplIiwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIk9wZXJhdGlvblByb2Nlc3NpbmdFcnJvciIsIm9wdGlvbnMiLCJkcG9wTm9uY2VzIiwiaXNDcnlwdG9LZXkiLCJDcnlwdG9LZXkiLCJpc1ByaXZhdGVLZXkiLCJ0eXBlIiwiaXNQdWJsaWNLZXkiLCJTVVBQT1JURURfSldTX0FMR1MiLCJwcm9jZXNzRHBvcE5vbmNlIiwicmVzcG9uc2UiLCJoZWFkZXJzIiwidXJsIiwiVVJMIiwib3JpZ2luIiwibm9ybWFsaXplVHlwIiwidG9Mb3dlckNhc2UiLCJpc0pzb25PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJwcmVwYXJlSGVhZGVycyIsIkhlYWRlcnMiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJUeXBlRXJyb3IiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsImRpc2NvdmVyeVJlcXVlc3QiLCJpc3N1ZXJJZGVudGlmaWVyIiwicHJvdG9jb2wiLCJocmVmIiwiYWxnb3JpdGhtIiwicGF0aG5hbWUiLCJmZXRjaCIsIm1ldGhvZCIsInJlZGlyZWN0IiwidGhlbiIsInZhbGlkYXRlU3RyaW5nIiwicHJvY2Vzc0Rpc2NvdmVyeVJlc3BvbnNlIiwiZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyIiwiUmVzcG9uc2UiLCJzdGF0dXMiLCJhc3NlcnRSZWFkYWJsZVJlc3BvbnNlIiwianNvbiIsImlzc3VlciIsInJhbmRvbUJ5dGVzIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiZ2VuZXJhdGVSYW5kb21Db2RlVmVyaWZpZXIiLCJnZW5lcmF0ZVJhbmRvbVN0YXRlIiwiZ2VuZXJhdGVSYW5kb21Ob25jZSIsImNhbGN1bGF0ZVBLQ0VDb2RlQ2hhbGxlbmdlIiwiY29kZVZlcmlmaWVyIiwic3VidGxlIiwiZGlnZXN0IiwiZ2V0S2V5QW5kS2lkIiwia2lkIiwiZm9ybVVybEVuY29kZSIsInRva2VuIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY2xpZW50U2VjcmV0QmFzaWMiLCJjbGllbnRJZCIsImNsaWVudFNlY3JldCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJjcmVkZW50aWFscyIsInBzQWxnIiwiaGFzaCIsInJzQWxnIiwiZXNBbGciLCJuYW1lZEN1cnZlIiwia2V5VG9Kd3MiLCJnZXRDbG9ja1NrZXciLCJjbGllbnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImdldENsb2NrVG9sZXJhbmNlIiwidG9sZXJhbmNlIiwiTWF0aCIsInNpZ24iLCJlcG9jaFRpbWUiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJjbGllbnRBc3NlcnRpb24iLCJhcyIsImp0aSIsImF1ZCIsInRva2VuX2VuZHBvaW50IiwiZXhwIiwiaWF0IiwibmJmIiwiaXNzIiwiY2xpZW50X2lkIiwic3ViIiwicHJpdmF0ZUtleUp3dCIsImp3dCIsImFsZyIsImFzc2VydEFzIiwiYXNzZXJ0Q2xpZW50IiwiYXNzZXJ0Q2xpZW50U2VjcmV0IiwiYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5IiwiY2xpZW50QXV0aE1ldGhvZCIsImNsaWVudFByaXZhdGVLZXkiLCJhc3NlcnROb0NsaWVudFNlY3JldCIsImNsaWVudEF1dGhlbnRpY2F0aW9uIiwiYm9keSIsInRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kIiwiY2xpZW50X3NlY3JldCIsImhlYWRlciIsImNsYWltc1NldCIsInVzYWdlcyIsImluY2x1ZGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25hdHVyZSIsImtleVRvU3VidGxlIiwiaXNzdWVSZXF1ZXN0T2JqZWN0IiwicGFyYW1ldGVycyIsInByaXZhdGVLZXkiLCJVUkxTZWFyY2hQYXJhbXMiLCJjbGFpbXMiLCJyZXNvdXJjZSIsImdldEFsbCIsInBhcnNlIiwidHlwIiwiZHBvcFByb29mSnd0IiwiaHRtIiwiYWNjZXNzVG9rZW4iLCJwdWJsaWNLZXkiLCJub25jZSIsImV4dHJhY3RhYmxlIiwicHJvb2YiLCJqd2siLCJwdWJsaWNKd2siLCJodHUiLCJhdGgiLCJqd2tDYWNoZSIsIldlYWtNYXAiLCJrdHkiLCJlIiwibiIsIngiLCJ5IiwiY3J2IiwiZXhwb3J0S2V5IiwidmFsaWRhdGVFbmRwb2ludCIsImVuZHBvaW50IiwicmVzb2x2ZUVuZHBvaW50IiwibXRsc19lbmRwb2ludF9hbGlhc2VzIiwicHVzaGVkQXV0aG9yaXphdGlvblJlcXVlc3QiLCJEUG9QIiwiYXV0aGVudGljYXRlZFJlcXVlc3QiLCJpc09BdXRoMkVycm9yIiwiZXJyb3IiLCJ1bnF1b3RlIiwic2xpY2UiLCJTUExJVF9SRUdFWFAiLCJTQ0hFTUVTX1JFR0VYUCIsInd3d0F1dGgiLCJzY2hlbWUiLCJwYXJhbXMiLCJzcGxpdCIsImlkeCIsInBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyIsInJlc3VsdCIsImluZGV4IiwibWF0Y2hBbGwiLCJjaGFsbGVuZ2VzIiwibWFwIiwiaW5kZXhPZiIsIm90aGVycyIsIm5leHQiLCJwcm9jZXNzUHVzaGVkQXV0aG9yaXphdGlvblJlc3BvbnNlIiwiZXJyIiwiaGFuZGxlT0F1dGhCb2R5RXJyb3IiLCJyZXF1ZXN0X3VyaSIsImV4cGlyZXNfaW4iLCJwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QiLCJ1c2VySW5mb1JlcXVlc3QiLCJ1c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXBwZW5kIiwiandrc0NhY2hlIiwiZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkiLCJjaGVja1N1cHBvcnRlZEp3c0FsZyIsImp3a3MiLCJhZ2UiLCJqd2tzUmVxdWVzdCIsInByb2Nlc3NKd2tzUmVzcG9uc2UiLCJjYW5kaWRhdGVzIiwia2V5cyIsImZpbHRlciIsInVzZSIsImtleV9vcHMiLCJpbXBvcnRKd2siLCJza2lwU3ViamVjdENoZWNrIiwiZ2V0Q29udGVudFR5cGUiLCJwcm9jZXNzVXNlckluZm9SZXNwb25zZSIsImV4cGVjdGVkU3ViamVjdCIsInZhbGlkYXRlSnd0IiwidGV4dCIsImNoZWNrU2lnbmluZ0FsZ29yaXRobSIsImJpbmQiLCJ1c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwibm9TaWduYXR1cmVDaGVjayIsInZhbGlkYXRlT3B0aW9uYWxBdWRpZW5jZSIsInZhbGlkYXRlT3B0aW9uYWxJc3N1ZXIiLCJ0b2tlbkVuZHBvaW50UmVxdWVzdCIsImdyYW50VHlwZSIsInJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdCIsInJlZnJlc2hUb2tlbiIsImFkZGl0aW9uYWxQYXJhbWV0ZXJzIiwiaWRUb2tlbkNsYWltcyIsImdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMiLCJyZWYiLCJpZF90b2tlbiIsInByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZSIsImlnbm9yZUlkVG9rZW4iLCJpZ25vcmVSZWZyZXNoVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJ0b2tlbl90eXBlIiwicmVmcmVzaF90b2tlbiIsInNjb3BlIiwiaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZVByZXNlbmNlIiwidmFsaWRhdGVJc3N1ZXIiLCJ2YWxpZGF0ZUF1ZGllbmNlIiwiYXpwIiwicmVxdWlyZV9hdXRoX3RpbWUiLCJhdXRoX3RpbWUiLCJwcm9jZXNzUmVmcmVzaFRva2VuUmVzcG9uc2UiLCJicmFuZGVkIiwiV2Vha1NldCIsImJyYW5kIiwic2VhcmNoUGFyYW1zIiwiYWRkIiwiYXV0aG9yaXphdGlvbkNvZGVHcmFudFJlcXVlc3QiLCJjYWxsYmFja1BhcmFtZXRlcnMiLCJyZWRpcmVjdFVyaSIsImNvZGUiLCJnZXRVUkxTZWFyY2hQYXJhbWV0ZXIiLCJqd3RDbGFpbU5hbWVzIiwiY19oYXNoIiwic19oYXNoIiwiY25mIiwicmVxdWlyZWQiLCJjbGFpbSIsImV4cGVjdE5vTm9uY2UiLCJza2lwQXV0aFRpbWVDaGVjayIsInByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlIiwiZXhwZWN0ZWROb25jZSIsIm1heEFnZSIsImRlZmF1bHRfbWF4X2FnZSIsInByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9BdXRoMlJlc3BvbnNlIiwiY2hlY2tKd3RUeXBlIiwiY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QiLCJwcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZSIsInJldm9jYXRpb25SZXF1ZXN0IiwicHJvY2Vzc1Jldm9jYXRpb25SZXNwb25zZSIsImJvZHlVc2VkIiwiaW50cm9zcGVjdGlvblJlcXVlc3QiLCJyZXF1ZXN0Snd0UmVzcG9uc2UiLCJpbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJwcm9jZXNzSW50cm9zcGVjdGlvblJlc3BvbnNlIiwiaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidG9rZW5faW50cm9zcGVjdGlvbiIsImFjdGl2ZSIsImV2ZXJ5IiwiY2FsbCIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3JfdXJpIiwiYWxncyIsImNoZWNrUnNhS2V5QWxnb3JpdGhtIiwibW9kdWx1c0xlbmd0aCIsImVjZHNhSGFzaE5hbWUiLCJzYWx0TGVuZ3RoIiwicGFyc2VJbnQiLCJqd3MiLCJjaGVja0FsZyIsImdldEtleSIsInByb3RlY3RlZEhlYWRlciIsInBheWxvYWQiLCJlbmNvZGVkU2lnbmF0dXJlIiwiY3JpdCIsInZlcmlmaWVkIiwidmVyaWZ5IiwidmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UiLCJleHBlY3RlZFN0YXRlIiwiandrc191cmkiLCJhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhdXRob3JpemF0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSIsImlkVG9rZW5IYXNoIiwiZGF0YSIsImlkVG9rZW5IYXNoTWF0Y2hlcyIsImFjdHVhbCIsImV4cGVyaW1lbnRhbF92YWxpZGF0ZURldGFjaGVkU2lnbmF0dXJlUmVzcG9uc2UiLCJleHBlY3ROb1N0YXRlIiwiYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCIsInJlcXVpcmVkQ2xhaW1zIiwic2tpcFN0YXRlQ2hlY2siLCJzdGF0ZSIsImFsZ1RvU3VidGxlIiwiZXh0IiwiaW1wb3J0S2V5IiwiZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QiLCJwcm9jZXNzRGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlIiwiZGV2aWNlX2NvZGUiLCJ1c2VyX2NvZGUiLCJ2ZXJpZmljYXRpb25fdXJpIiwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSIsImludGVydmFsIiwiZGV2aWNlQ29kZUdyYW50UmVxdWVzdCIsImRldmljZUNvZGUiLCJwcm9jZXNzRGV2aWNlQ29kZVJlc3BvbnNlIiwiZ2VuZXJhdGVLZXlQYWlyIiwiYXNzaWduIiwicHVibGljRXhwb25lbnQiLCJnZW5lcmF0ZUtleSIsIm5vcm1hbGl6ZUh0dSIsInNlYXJjaCIsInZhbGlkYXRlRFBvUCIsInJlcXVlc3QiLCJhY2Nlc3NUb2tlbkNsYWltcyIsImprdCIsImRwb3Bfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsImRpZmYiLCJhYnMiLCJjb21wb25lbnRzIiwiZXhwZXJpbWVudGFsX3ZhbGlkYXRlSnd0QWNjZXNzVG9rZW4iLCJleHBlY3RlZEF1ZGllbmNlIiwiUmVxdWVzdCIsImF1dGhvcml6YXRpb24iLCJyZXF1aXJlRFBvUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/oauth4webapi/build/index.js\n");

/***/ })

};
;